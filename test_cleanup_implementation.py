#!/usr/bin/env python3
"""
Script de test pour valider l'impl√©mentation du cleanup des torrents
selon la roadmap CLEANUP_ROADMAP.md
"""

import sqlite3
import json
import requests
import sys
import os

def test_database_extensions():
    """Teste les extensions de la base de donn√©es pour le cleanup"""
    print("üîç Test des extensions de base de donn√©es...")
    
    try:
        db_path = '/home/kesurof/Projet_Gihtub/Redriva/data/symlink.db'
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # V√©rifier les nouvelles colonnes cleanup
        cursor.execute("PRAGMA table_info(symlink_config)")
        columns = [col[1] for col in cursor.fetchall()]
        
        cleanup_columns = [
            'cleanup_enabled', 'zurg_path', 'cleanup_min_age_days', 'cleanup_min_size_mb',
            'organized_media_path', 'cleanup_dry_run_default', 'rd_api_key',
            'cleanup_batch_limit', 'cleanup_delay_ms', 'cleanup_ignore_extensions',
            'cleanup_whitelist', 'cleanup_match_threshold', 'cleanup_max_workers',
            'cleanup_preserve_recent', 'cleanup_detailed_logs', 'cleanup_auto_schedule'
        ]
        
        missing_columns = [col for col in cleanup_columns if col not in columns]
        
        if missing_columns:
            print(f"‚ùå Colonnes manquantes: {missing_columns}")
            return False
        else:
            print("‚úÖ Toutes les colonnes cleanup sont pr√©sentes")
            return True
            
    except Exception as e:
        print(f"‚ùå Erreur test DB: {e}")
        return False
    finally:
        if 'conn' in locals():
            conn.close()

def test_api_endpoints():
    """Teste les nouveaux endpoints API cleanup"""
    print("\nüåê Test des endpoints API cleanup...")
    
    base_url = 'http://localhost:5000'
    endpoints_to_test = [
        ('/api/symlink/cleanup/config', 'GET'),
        ('/api/symlink/cleanup/analyze', 'POST'),
        ('/api/symlink/test/zurg', 'POST'),
        ('/api/symlink/test/realdebrid', 'POST')
    ]
    
    results = []
    
    for endpoint, method in endpoints_to_test:
        try:
            url = base_url + endpoint
            
            if method == 'GET':
                response = requests.get(url, timeout=5)
            else:
                response = requests.post(url, 
                    json={'test': True}, 
                    headers={'Content-Type': 'application/json'},
                    timeout=5
                )
            
            if response.status_code in [200, 400, 500]:  # Connexion OK
                results.append((endpoint, '‚úÖ'))
                print(f"   ‚úÖ {endpoint} ({method}) - Status: {response.status_code}")
            else:
                results.append((endpoint, '‚ùå'))
                print(f"   ‚ùå {endpoint} ({method}) - Status: {response.status_code}")
                
        except requests.exceptions.ConnectionError:
            results.append((endpoint, 'üö´'))
            print(f"   üö´ {endpoint} ({method}) - Serveur non accessible")
        except Exception as e:
            results.append((endpoint, '‚ùå'))
            print(f"   ‚ùå {endpoint} ({method}) - Erreur: {e}")
    
    success_count = sum(1 for _, status in results if status == '‚úÖ')
    total_count = len(results)
    
    print(f"\nüìä R√©sultats endpoints: {success_count}/{total_count} accessibles")
    return success_count == total_count

def test_html_interface():
    """Teste la pr√©sence des √©l√©ments HTML pour le cleanup"""
    print("\nüåê Test de l'interface HTML...")
    
    try:
        html_path = '/home/kesurof/Projet_Gihtub/Redriva/src/templates/symlink_tool.html'
        
        if not os.path.exists(html_path):
            print(f"‚ùå Fichier HTML non trouv√©: {html_path}")
            return False
            
        with open(html_path, 'r', encoding='utf-8') as f:
            html_content = f.read()
        
        # √âl√©ments requis selon la roadmap
        required_elements = [
            'id="cleanup-tab"',           # Onglet cleanup
            'id="cleanup-stats"',         # Statistiques
            'id="cleanup-results"',       # Tableau des r√©sultats
            'id="selectAllCleanup"',      # S√©lection multiple
            'id="cleanup-torrents-list"', # Liste des torrents
            'analyzeUnusedTorrents(',      # Bouton d'analyse (fonction)
            'id="zurg-path"',             # Configuration Zurg
            'id="cleanup-enabled"',       # Activation cleanup
            'id="rd-api-key"',            # API Key RD
            'testZurgConnection(',        # Test Zurg (fonction)
            'testRealDebridConnection('   # Test RD (fonction)
        ]
        
        missing_elements = []
        for element in required_elements:
            if element not in html_content:
                missing_elements.append(element)
        
        if missing_elements:
            print(f"‚ùå √âl√©ments HTML manquants: {missing_elements}")
            return False
        else:
            print("‚úÖ Tous les √©l√©ments HTML cleanup sont pr√©sents")
            return True
            
    except Exception as e:
        print(f"‚ùå Erreur test HTML: {e}")
        return False

def test_javascript_functions():
    """Teste la pr√©sence des fonctions JavaScript pour le cleanup"""
    print("\nüìú Test des fonctions JavaScript...")
    
    try:
        js_path = '/home/kesurof/Projet_Gihtub/Redriva/src/static/js/symlink_tool.js'
        
        if not os.path.exists(js_path):
            print(f"‚ùå Fichier JS non trouv√©: {js_path}")
            return False
            
        with open(js_path, 'r', encoding='utf-8') as f:
            js_content = f.read()
        
        # Fonctions requises selon la roadmap
        required_functions = [
            'function loadCleanup(',
            'function analyzeUnusedTorrents(',
            'function displayCleanupResults(',
            'function updateCleanupSelection(',
            'function toggleSelectAllCleanup(',
            'function clearCleanupSelection(',
            'function confirmCleanupDeletion(',
            'function deleteSelectedCleanupTorrents(',
            'function testZurgConnection(',
            'function testRealDebridConnection(',
            'function saveCleanupConfiguration(',
            'function loadCleanupConfiguration(',
            'function populateCleanupConfigForm('
        ]
        
        missing_functions = []
        for func in required_functions:
            if func not in js_content:
                missing_functions.append(func.replace('function ', '').replace('(', ''))
        
        if missing_functions:
            print(f"‚ùå Fonctions JS manquantes: {missing_functions}")
            return False
        else:
            print("‚úÖ Toutes les fonctions JavaScript cleanup sont pr√©sentes")
            return True
            
    except Exception as e:
        print(f"‚ùå Erreur test JS: {e}")
        return False

def test_backend_class():
    """Teste la pr√©sence de la classe TorrentCleanupAnalyzer"""
    print("\nüêç Test de la classe backend...")
    
    try:
        backend_path = '/home/kesurof/Projet_Gihtub/Redriva/src/symlink_tool.py'
        
        if not os.path.exists(backend_path):
            print(f"‚ùå Fichier backend non trouv√©: {backend_path}")
            return False
            
        with open(backend_path, 'r', encoding='utf-8') as f:
            backend_content = f.read()
        
        # M√©thodes requises selon la roadmap
        required_methods = [
            'class TorrentCleanupAnalyzer:',
            'def scan_zurg_usage(',
            'def normalize_torrent_name(',
            'def find_unused_torrents(',
            'def calculate_age_days(',
            'def delete_torrents_via_rd_api(',
            'def test_zurg_connection(',
            'def test_realdebrid_connection(',
            "@app.route('/api/symlink/cleanup/config'",
            "@app.route('/api/symlink/cleanup/analyze'",
            "@app.route('/api/symlink/cleanup/delete'"
        ]
        
        missing_methods = []
        for method in required_methods:
            if method not in backend_content:
                missing_methods.append(method)
        
        if missing_methods:
            print(f"‚ùå M√©thodes/routes backend manquantes: {missing_methods}")
            return False
        else:
            print("‚úÖ Classe TorrentCleanupAnalyzer et routes compl√®tes")
            return True
            
    except Exception as e:
        print(f"‚ùå Erreur test backend: {e}")
        return False

def main():
    """Ex√©cute tous les tests de validation"""
    print("üöÄ Validation de l'impl√©mentation cleanup des torrents Real-Debrid")
    print("=" * 60)
    
    tests = [
        ("Base de donn√©es", test_database_extensions),
        ("Endpoints API", test_api_endpoints),
        ("Interface HTML", test_html_interface),
        ("JavaScript", test_javascript_functions),
        ("Backend Python", test_backend_class)
    ]
    
    results = []
    
    for test_name, test_func in tests:
        print(f"\nüìã Test: {test_name}")
        print("-" * 40)
        result = test_func()
        results.append((test_name, result))
    
    print("\n" + "=" * 60)
    print("üìä R√âSUM√â DES TESTS")
    print("=" * 60)
    
    success_count = 0
    for test_name, result in results:
        status = "‚úÖ R√âUSSI" if result else "‚ùå √âCHEC"
        print(f"   {status:<12} {test_name}")
        if result:
            success_count += 1
    
    total_tests = len(results)
    print(f"\nüéØ Score: {success_count}/{total_tests} tests r√©ussis")
    
    if success_count == total_tests:
        print("üéâ Impl√©mentation cleanup conforme √† la roadmap !")
        return True
    else:
        print("‚ö†Ô∏è  Impl√©mentation incompl√®te - voir les erreurs ci-dessus")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
